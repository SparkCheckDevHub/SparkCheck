@page "/matchqueue"
@layout MainLayout
@inherits SparkCheck.Shared.SecureBasePage
@implements IAsyncDisposable
@inject UserService UserService
@inject MatchService MatchService
@inject HttpClient HttpClient

<MudHidden Breakpoint="Breakpoint.MdAndUp">
<MudStack Spacing="8" AlignItems="AlignItems.Center">
    @if (!string.IsNullOrEmpty(errorMessage)) {
	        <MudAlert Severity="Severity.Error" Elevation="0" Dense="true" Style="margin-bottom: 1rem;">
	            @errorMessage
	        </MudAlert>
    }

    <MudText Typo="Typo.h5" Class="mb-4 text-center spark-text">
        Find a match now
    </MudText>

    <MudText Typo="Typo.subtitle1" Class="mb-4 text-center spark-text">
        @($"There are currently {onlineUserCount} users online")
    </MudText>

        <MudStack Spacing="2" Class="w-full" AlignItems="AlignItems.Center" JustifyContent="JustifyContent.Center">
<MudIconButton
    Icon="@Icons.Material.Filled.Favorite"
    Class="@HeartCssClass"      
    DisableRipple="true"
    OnClick="ToggleMatching"
    AriaLabel="Start matching" />
            <MudText class="spark-text" Typo="Typo.caption">
                @PendingMessage
            </MudText>
            @if (pendingAction != QueueAction.None) {
                <MudProgressLinear Value="@((10 - secondsLeft) * 10)" Class="w-64" />
            }
        </MudStack>
    <MudSpacer />
</MudStack>
</MudHidden>

<!-- DESKTOP/TABLET VIEW (MD and up) -->
<MudHidden Breakpoint="Breakpoint.SmAndDown">
	<MudContainer MaxWidth="MaxWidth.Medium">
		<MudStack Spacing="8" AlignItems="AlignItems.Center">
			<img src="images/logo.png" alt="SparkCheck logo" style="width: 70%;" />

			<MudText Typo="Typo.h6" Align="Align.Center" Class="spark-text">
				SparkCheck is optimized for mobile devices.
			</MudText>

			<MudText Typo="Typo.body1" Align="Align.Center" Class="spark-text">
				For the best experience, please open SparkCheck on your phone and save it to your home screen.
			</MudText>

			<MudText Typo="Typo.subtitle2" Align="Align.Center" Class="spark-text">
				© 2025 SparkCheck | Cortanix™
			</MudText>
		</MudStack>
	</MudContainer>
</MudHidden>

@code {
    // --- state ---
    private bool blnMatchStopped = false;
    private int onlineUserCount;
    private string? errorMessage;

    private enum QueueAction { None, Pending, Queueing }
    private QueueAction pendingAction = QueueAction.None;
    private int secondsLeft = 0;
    private CancellationTokenSource? pendingCts;

    // --- computed UI text/classes ---
    private string TooltipText =>
        pendingAction switch {
            QueueAction.Pending => $"Starting in {secondsLeft}s… Tap to cancel",
            QueueAction.Queueing => "Stop Matching",
            QueueAction.None => "Start Matching",
            _ => "Start Matching"
        };

    private string PendingMessage => pendingAction switch {
            QueueAction.Pending => $"Match starting in {secondsLeft} second{(secondsLeft == 1 ? "" : "s")}… Tap again to cancel.",
            QueueAction.Queueing => blnMatchStopped ? "Stopping..." : "Looking for a match... Tap again to cancel.",
            QueueAction.None => "Tap heart to start matching."
        };

    private string HeartCssClass =>
        $"gold-heart {(pendingAction == QueueAction.None ? "steady" : "countdown" )}";

    protected override async Task OnInitializedAsync()
    {
        onlineUserCount = await UserService.GetOnlineUserCountAsync();
        if (await MatchService.GetLatestActiveMatchAsync(UserSession.intUserID) != null)
        {
            Navigation.NavigateTo("/match");
        }
    }
    public async ValueTask DisposeAsync()
    {
        // cancel any pending countdown, stop matching
        pendingCts?.Cancel();        
        pendingCts?.Dispose();        
        pendingCts = null;
        blnMatchStopped = false;
        await StopMatching();
    }
    private async Task ToggleMatching() {
        switch (pendingAction) {
            case QueueAction.Pending: {
                pendingCts?.Cancel();        
                pendingCts?.Dispose();
                pendingCts = null;
                pendingAction = QueueAction.None;
                StateHasChanged( );
            } break;
            case QueueAction.Queueing: {
                blnMatchStopped = true;
                StateHasChanged( );
                await StopMatching();
            } break;
            case QueueAction.None: {
                StartGracePeriod();                
            } break;
        }
    }
    private void StartGracePeriod() {
        pendingAction = QueueAction.Pending;
        errorMessage = null;
        secondsLeft = 5;
        pendingCts?.Cancel();
        pendingCts?.Dispose();
        pendingCts = new CancellationTokenSource();
        _ = RunGracePeriodAsync(pendingCts.Token);
        StateHasChanged();
    }
    private async Task RunGracePeriodAsync(CancellationToken token) {
        try {
            while (secondsLeft > 0) {
                await Task.Delay(1000, token);
                secondsLeft--;
                StateHasChanged();
            }
    
            pendingCts?.Dispose();
            pendingCts = null;
            await StartMatching();
        }
        catch (OperationCanceledException) { /* user canceled */ }
        finally {
            blnMatchStopped = false;
            pendingAction = QueueAction.None;
            secondsLeft = 0;
            StateHasChanged();
        }
    }
    private async Task StartMatching()
    {
        errorMessage = null;
        pendingAction = QueueAction.Queueing;
        blnMatchStopped = false;
        StateHasChanged();

        try
        {
            var response = await
            HttpClient.GetAsync($"http://sparkcheck-matcher:9988/enterQueue?intUserID={UserSession.intUserID}");
            if (response.IsSuccessStatusCode)
            {
                var content = await response.Content.ReadAsStringAsync();
                var json = System.Text.Json.JsonDocument.Parse(content);
                var status = json.RootElement.GetProperty("status").GetString();
                switch (status)
                {
                    case "success":
                        Navigation.NavigateTo("/match");
                        break;
                    case "error":
                        errorMessage = json.RootElement.GetProperty("message").GetString();
                        await StopMatching();
                        break;
                    case "stopped":
                        break;
                    default:
                        errorMessage = content;
                        break;
                }
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error starting match: {ex.Message}";
        }
        finally
        {
            blnMatchStopped = false;
            pendingAction = QueueAction.None;
            StateHasChanged();
        }
    }

    private async Task StopMatching()
    {
        try
        {
            await HttpClient.GetAsync($"http://sparkcheck-matcher:9988/exitQueue?intUserID={UserSession.intUserID}");
        }
        catch (Exception ex)
        {
            errorMessage = $"Error stopping match: {ex.Message}";
        }
    }
}